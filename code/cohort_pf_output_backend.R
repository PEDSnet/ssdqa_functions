
########################## DATA PRE PROCESSING #####################################

#' Compute median fact counts by visit & fact type and by site, visit, & fact type
#'
#' @param data_input the list output of `combine_study_facts`
#' @param agegrp boolean that determines whether the output should also
#'               be grouped by age group
#'
#' @return dataframe that contains the total median number of facts for that visit & fact_type
#'         as well as the median number of facts for the site, visit, & fact type for each
#'         study 
#' 
compute_pf_medians <- function(data_input,
                               site_col,
                               agegrp=NULL,
                               codeset=NULL) {
  
  
  data_input_cols <- data_input %>% colnames()
  
  if('cohort' %in% data_input_cols) {
    data_input_grp <- 
      data_input %>% group_by(cohort)
  } else {data_input_grp <- data_input}
  
  if(is.data.frame(agegrp)) {data_input_grp <- data_input_grp %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input_grp <- data_input_grp %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_distance_medians_tbl <- 
    data_input_grp %>% 
    group_by(study,
             visit_type,
             domain,
             .add=TRUE) %>% 
    mutate(median_all_with0s=median(var_val),
           median_all_without0s=median(var_val[var_val!=0])) %>% 
    ungroup()
  
  site_distance_final <- 
    data_input_grp %>% 
    left_join(site_distance_medians_tbl) %>% 
    group_by(study,
             !!sym(site_col),
             visit_type,
             domain,
             median_all_with0s,
             median_all_without0s,
             .add=TRUE) %>% 
    summarise(n_tot=n(),
              n_w_fact=sum(var_ever),
              median_site_with0s=median(var_val),
              median_site_without0s=median(var_val[var_val!=0])) %>% ungroup() #%>% 
    #mutate(prop_all_w_fact=round(n_w_fact/n_tot,3))
  
  site_distance_final <- 
    site_distance_final %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x), 0)))
  
  
  site_distance_final
  
}


#' Compute distance from mean
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param agegrp a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a dataframe that summarises the number of patients with fact counts that fall +/- 3 SD away from the mean
#'         both at fact and site + fact levels
#'         
#'         contains columns: person_id, start_date, end_date, fu, site, domain, var_val, var_ever, study,
#'                           visit_type, n_fact, zscore_fact, outlier_fact, prop_outlier_fact, n_site_fact,
#'                           zscore_site_fact, outlier_site_fact, prop_outlier_site_fact
#' 
compute_dist_mean_pf <- function(data_input,
                                 site_col,
                                 n_sd = 2,
                                 agegrp = NULL,
                                 codeset = NULL) {
  
  if(is.data.frame(agegrp)) {data_input <- data_input %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input <- data_input %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_dist_means_tbl <- 
    data_input %>% 
    group_by(study,
             visit_type,
             domain,
             .add=TRUE) %>% 
    mutate(n_fact=n(),
           mean_fact=mean(var_val),
           sd_fact=sd(var_val),
           zscore_fact = ((var_val - mean_fact) / sd_fact),
           abs_z = abs(zscore_fact),
           outlier = case_when(abs_z > n_sd ~ 1L,
                               TRUE ~ 0L),
           outlier_fact = sum(outlier),
           prop_outlier_fact = round(outlier_fact / n_fact, 3)) %>% 
    ungroup() %>%
    select(-c(outlier, abs_z, mean_fact, sd_fact))
  
  
  site_dist_means_final <- 
    data_input %>% 
    left_join(site_dist_means_tbl) %>% 
    group_by(study,
             !!sym(site_col),
             visit_type,
             domain,
             n_fact,
             outlier_fact,
             prop_outlier_fact,
             .add=TRUE) %>% 
    summarise(n_site_fact=n(),
              mean_site_fact=mean(var_val),
              sd_site_fact=sd(var_val),
              zscore_site_fact = ((var_val - mean_site_fact) / sd_site_fact),
              abs_z = abs(zscore_site_fact),
              outlier = case_when(abs_z > n_sd ~ 1L,
                                  TRUE ~ 0L),
              outlier_site_fact = sum(outlier),
              prop_outlier_site_fact = round(outlier_site_fact / n_site_fact, 3)) %>% 
    ungroup() %>%
    select(-c(outlier, abs_z, mean_site_fact, sd_site_fact, zscore_site_fact)) %>% distinct()
  
  site_dist_means_final <- 
    site_dist_means_final %>% replace(is.na(.), 0) 
  
  site_dist_means_final
}


############################ K-means prep ######################################

#' Prepare data for k-means computation
#'
#' @param dat input table generated by `compute_pf_medians`
#' @param age_group a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a list of matricies (one per distinct grouping of facet variables) with 
#'         one median value per site and per domain
#' 
prep_kmeans <- function(dat,
                        output,
                        facet_vars) {
  
  kmeans_list <- list()
  
if(!is.null(facet_vars)){
  select_cols <- c('site', 'domain', output, facet_vars)
  
  #facet_list <- dat %>% select(!!sym(facet_var)) %>% distinct() %>% pull()
  
  kmeans_prep <- 
    dat %>% 
    select(!!!syms(select_cols)) %>%
    #filter(!!sym(facet_var) == facet_list[[i]]) %>% 
    pivot_wider(id_cols = site,
                names_from = c(domain, !!!syms(facet_vars)),
                values_from = !!sym(output)) 
  
  kmeans_prep <- 
    kmeans_prep %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
  
  cols <- kmeans_prep %>% select(-site) %>% colnames()
  
  domains <- dat %>% select(domain) %>% distinct() %>% pull()
  
  prep_regex <- function(domains){
    domains = c(domains)
    domain_options = paste(domains, collapse = '|')
    paste0("(", domain_options, ")+_")
  }
  
  regex <- prep_regex(domains)
  
  facet_list <- lapply(cols, function(x){str_remove_all(string = x, pattern = regex)}) %>% unique()
  
  #facet_list <- lapply(cols, function(x){sub("^[^_]*_", "", x)}) %>% unique()
  
  for(i in 1:length(facet_list)){
  
  kmeans_mat <- 
    kmeans_prep %>% 
    column_to_rownames(., var='site')
  
  facet_kmeans <- kmeans_mat[, grepl(facet_list[[i]], names(kmeans_mat))]
  
  kmeans_scaled <- scale(facet_kmeans) 
  
  kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
  
  kmeans_final <- kmeans_scaled
  
  kmeans_list[[i]] <- list(kmeans_scaled,
                           facet_list[[i]])
  }
  
  }else{
    
    select_cols <- c('site', 'domain', output)
      
      kmeans_prep <- 
        dat %>% 
        select(all_of(select_cols)) %>%
        pivot_wider(id_cols = site,
                    names_from = domain,
                    values_from = !!sym(output)) 
      
      kmeans_prep <- 
        kmeans_prep %>% replace(is.na(.), 0) %>% 
        mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
      
      kmeans_mat <- 
        kmeans_prep %>% 
        column_to_rownames(., var='site')
      
      kmeans_scaled <- scale(kmeans_mat) 
      
      kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
      
      kmeans_list[[1]] <- list(kmeans_scaled,
                               "K-Means Cluster Analysis")
    
  }
  
  kmeans_list
  
  }


#' K-Means Output Generation
#'
#' @param kmeans_list a list of output tables from `prep_kmeans`; one table per distinct 
#'                    grouping of facet variables
#' @param centers an integer that denotes the number of clusters that should be
#'                generated
#'
#' @return a list of graphs, with one graph per distinct grouping of facet variables, 
#'         where site and domain are the dimensions
#' 
produce_kmeans_output <- function(kmeans_list,
                                  centers){
  
  output_list <- list()

  for(i in 1:length(kmeans_list)){
    
    if(ncol(kmeans_list[[i]][[1]]) == 0 || is.null(kmeans_list[[i]][[1]])){next}
    
    set.seed(123)
    k <- kmeans(kmeans_list[[i]][[1]], centers=centers)
    output_list[[i]] <- fviz_cluster(k, data=kmeans_list[[i]][[1]],
                 main = paste0(paste0('K-Means Cluster Analysis: ', kmeans_list[[i]][[2]])),
                 palette = 'Dark2',
                 ggtheme = theme_minimal())
    }
  output_list
}


#' FOT Heuristic Check
#'
#' @param target_col the statistic that should be used to generate the output;
#'                   options based on user configurations are provided in the `parameter_summary`
#'                   csv file output by `pf_process`
#' @param tblx table output by `pf_process`, filtered to one domain
#' @param site_col defaults to `site`
#' @param time_col defaults to `start_date`
#' @param facet_var list of variables by which the user would like to facet the output;
#'                  should match the facets used in `check_fot_multisite`
#'
#' @return list of two tables:
#'           -@fot_heuristic: table with relevant descriptive columns (site + facet_vars) and
#'                            the heuristic check
#'           -@fot_heuristic_summary: table with a summary of the heuristic, including the mean, median,
#'                                    quantiles, stdev, and descriptive columns (site + facet_vars)
#' 
fot_check <- function(target_col,
                      tblx,
                      site_col='site',
                      time_col='start_date',
                      facet_var) {
  if(is.null(facet_var)){
    cols_to_keep <- c(eval(site_col),eval(time_col),'check')
    groupedlist1 <- c(time_col)
    groupedlist2 <- c(site_col)
  }else{
    cols_to_keep <- c(eval(site_col),eval(time_col),eval(facet_var),'check')
    groupedlist1 <- c(time_col, facet_var)
    groupedlist2 <- c(site_col, facet_var)
  }
  
  rv <- FALSE
  rv_agg <- FALSE
  #base tbl to make a network wide version of the check
  agg_check <- tblx %>% group_by(!!!syms(groupedlist1)) %>%
    summarise(!!sym(target_col) := sum(!!sym(target_col))) %>%
    ungroup() %>%
    mutate({{site_col}}:='all')  # I need a cheat sheet of when {{x}}/eval(x)/!!sym(x) will actually work
  
  #for (target_check in tblx %>% select(!!sym(check_col)) %>% distinct() %>% pull()) {
  for (target_site in tblx %>% select(!!sym(site_col)) %>% distinct() %>% pull()) {
    foo <- fot_check_calc(tblx %>%
                            filter(site==target_site),
                          site_col='site',
                          time_col,
                          target_col) %>% collect()
    if(!is.logical(rv)){
      rv <- union(rv, foo)
    } else {
      rv <- foo
    }
  }
  
  bar <- fot_check_calc(agg_check,
                        site_col,time_col,target_col) %>%
    select(cols_to_keep) %>% collect()
  if(!is.logical(rv_agg)){
    rv_agg <- union(rv_agg, bar)
  } else {
    rv_agg <- bar
  }
  
  rv_summary <- rv %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect()
  
  rv_summary_allsites <- rv_agg %>%
    filter(site=='all') %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect() %>%
    mutate(site='all')
  
  
  return(list(fot_heuristic= dplyr::union(rv %>% select(cols_to_keep),
                                          rv_agg),
              fot_heuristic_summary=dplyr::union(rv_summary,
                                                 rv_summary_allsites)))
}


#' FOT Heuristic Check Calculation
#'
#' @param tblx table output by `pf_process`, filtered to one domain
#' @param site_col defaults to `site`
#' @param time_col defaults to `start_date`
#' @param target_col the statistic that should be used to generate the output;
#'                   options based on user configurations are provided in the `parameter_summary`
#'                   csv file output by `pf_process`
#'
#' @return dataframe with normalized distribution for specified domain based on the following heuristic:
#'         
#'         (month)/((month-1) x .25+(month+1) x .25+(month-12) x .5)
#' 
fot_check_calc <- function(tblx, 
                           site_col = 'site',
                           time_col = 'start_date', 
                           target_col) {
  tblx %>%
    arrange(!! sym(site_col), !! sym(time_col)) %>% 
    mutate(
      lag_1 = lag(!!sym(target_col)),
      lag_1_plus = lead(!!sym(target_col),1),
      lag_12 = lag(!!sym(target_col),12),
      check_denom = (lag(!!sym(target_col))*.25 +
                       lead(!!sym(target_col),1)*.25 +
                       lag(!!sym(target_col),12)*.5)) %>%
    # check_denom()) %>% 
    filter(check_denom!=0) %>%
    mutate(check = !!sym(target_col)/check_denom-1)
}


#' fot table computing distance from "all" check
#'
#' @param fot_check_output first element of list output from `fot_check`
#'
#' @return tbl with the following columns:
#' domain | check_name | month_end | centroid | site | check | distance
#'
#' The `distance` column measures, for each site/domain/check/month combination,
#' the distance between the site's normalized `check` output compared to
#' all sites combined.
#'

check_fot_all_dist <- function(fot_check_output) {
  
  just_all <-
    fot_check_output %>%
    filter(site=='all') %>%
    rename(centroid=check) %>%
    select(-c(site))
  
  combined <-
    just_all %>%
    inner_join(
      fot_check_output
    ) %>% mutate(
      distance=round(check,3)-round(centroid,3)
    )
}

#' Execute all FOT functions
#' 
#' @param tblx dataframe output by `pf_process`
#' @param target_col the statistic that should be used to generate the output;
#'                   options based on user configurations are provided in the `parameter_summary`
#'                   csv file output by `pf_process`
#' @param site_col defaults to `site`
#' @param time_col defaults to `start_date`
#' @param domain_list list of available domains in `tblx` to be used in loop
#' @param facet_var list of variables by which the user would like to facet the output
#' 
#' @return dataframe with normalized distribution of facts for each site, domain, and facet variable
#'         based on the following heuristic
#'         
#'         (month)/((month-1) x .25+(month+1) x .25+(month-12) x .5)

check_fot_multisite <- function(tblx,
                                target_col,
                                site_col = 'site',
                                time_col = 'start_date', 
                                domain_list,
                                facet_var = NULL) {
  
  final_all <- list()
  
  for(i in 1:length(domain_list)) {
    
    tblx_input <- tblx %>% filter(domain == domain_list[[i]]) %>% 
      group_split(!!!syms(facet_var))
    
    temp_rslt <- list()
    
    for(k in 1:length(tblx_input)){
    fot_output <- fot_check(tblx=tblx_input[[k]] %>% ungroup(),
                            target_col=target_col,
                            site_col=site_col,
                            time_col=time_col,
                            facet_var=facet_var)
    
    fot_distance <- check_fot_all_dist(fot_output$fot_heuristic) %>% 
      mutate(grp_check=domain_list[[i]])
    
    temp_rslt[[k]] <- fot_distance
    
    }
    
    final_all[[i]] <- fot_distance
    
  }
  
  letsreduce <- reduce(.x=final_all,
                       .f=dplyr::union)
  
}


#' loops through each domain and produces interactive graph 
#' using `girafe` package
#' 
#' @param multisite_tbl a tbl with all sites and a `grp_check` column, as well as a 
#'                      `month_end`, `distance`, `site` columns; output from the 
#'                      `check_fot_multisite` function
#' @param date_breaks_str the window length for each unit of time on the x-axis
#' @param time_span the start and end dates for the time period on the x-axis
#' @param facet_var list of variables by which the user would like to facet the output;
#'                  should match the facets used in `check_fot_multisite`
#' @param site_colors_v the color palette that should be used for the sites; typically use
#'                      the palette output by `create_color_scheme`
#' 

create_multisite_exp <- function(multisite_tbl,
                                 date_breaks_str,
                                 time_span,
                                 facet_var = NULL,
                                 site_colors_v) {
  
  grp_list <- 
    multisite_tbl %>% 
    select(grp_check) %>% distinct() %>% pull() %>% as.list()
  
  grp_output <- list()
  
  for(i in grp_list) {
    
    if(is.null(facet_var)){
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }else{
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        facet_wrap(facets = eval(facet_var), scales = 'free_y')+
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }
    
    multi_girafe <- 
      girafe(ggobj = multisite_plot_exp,
             width_svg = 8,
             height_svg = 4) %>% 
      girafe_options(opts_tooltip(use_fill=TRUE, css='color:black;', offx=20),
                     opts_hover(css='fill:blue;stroke-width:2;'),
                     opts_hover_inv(css='opacity:0.3'))
    
    
    grp_output[[i]] <- multi_girafe
    #ggplotly(multisite_plot_exp)
  }
  
  grp_output
}

#' output of `check_fot_multisite` to look for points where
#' a site is +/- 2 MAD from the median/centoid
#' 
#' @param multisite_tbl a tbl with all sites and a `grp_check` column, as well as a `month_end`, 
#'                      `distance`, `site` columns; output from the `check_fot_multisite` function
#' @param facet_var list of variables by which the user would like to facet the output;
#'                  should match the facets used in `check_fot_multisite`
#' @param mad_dev an integer to define the deviation that should be used to compute the upper and lower MAD limits
#' 
#' @return dataframe that includes statistics relating to the number of outliers / anomalous measures are present
#'         in the data based on deviation from the MAD

produce_multisite_mad <- function(multisite_tbl,
                                  facet_var = NULL,
                                  mad_dev) {
  if(is.null(facet_var)){
    grp1 <- c('start_date', 'grp_check', 'centroid')
    grp2 <- c('site', 'grp_check')
  }else{
    grp1 <- c('start_date', 'grp_check', 'centroid', facet_var)
    grp2 <- c('site', 'grp_check', facet_var)
  }
  
  mad_computation <- 
    multisite_tbl %>% 
    group_by(!!!syms(grp1)) %>% 
    summarise(mad_pt=mad(check, center=centroid)) %>% 
    ungroup() %>% 
    mutate(lower_mad = mad_pt - (abs(mad_pt*mad_dev)),
           upper_mad = mad_pt + (abs(mad_pt*mad_dev)))
  
  full_tbl_outliers <- 
    multisite_tbl %>% ungroup() %>% 
    inner_join(mad_computation) %>% 
    mutate(
      outlier=case_when((distance < lower_mad) | (distance > upper_mad) ~ 1,
                        TRUE ~ 0)
    ) %>% filter(! site=='all')
  
  sites_grp_outliers <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    filter(outlier==1) %>% 
    summarise(grp_outlier_num=n()) %>%  ungroup() 
  
  sites_grp_ct_total <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    summarise(grp_total_num=n()) %>% ungroup()
  
  sites_grp_total <- 
    sites_grp_ct_total %>% 
    left_join(sites_grp_outliers) %>% 
    mutate(grp_outlier_prop = round(grp_outlier_num/grp_total_num,2))
  
  sites_total <- 
    sites_grp_total %>% ungroup() %>% 
    group_by(site) %>% 
    mutate(site_total_num=sum(grp_total_num, na.rm = TRUE),
           site_total_outlier=sum(grp_outlier_num, na.rm = TRUE)) %>% 
    mutate(site_outlier_prop=round(site_total_outlier/site_total_num,2)) %>% 
    rename(grp=grp_check)
  
}

#' generate color schemes for graphs based on user input or automatically
#' 
#' @param type - the type of color palette that should be used for generation
#'                   - @auto: a color palette will be generated automatically using RColorBrewer
#'                   - @manual: a custom color palette defined by the user in *domain_color_custom*
#'                              and *site_color_custom* will be used to create the color palette
#' @param site_list - the list of sites for which colors are required
#' @param domain_list - the list of domains for which colors are required
#' 
#' @return one csv file each for the site and domain variables that contain the name of the available options
#'         and the associated hex codes

create_color_scheme <- function(type = 'auto',
                                site_list,
                                domain_list){
  
  if(type == 'auto'){
    site_names <- site_list
    site_palette_base <- colorRampPalette(brewer.pal(8, "Dark2"))
    site_color <- setNames(site_palette_base(length(site_names)), site_names)
    as.data.frame(site_color) %>% rownames_to_column('site') %>%
      write.csv(file.path(base_dir, 'specs/site_color_config.csv'), row.names = FALSE)
    
    domain_names <- domain_list
    domain_palette_base <- colorRampPalette(brewer.pal(8, "Dark2"))
    domain_color <- setNames(domain_palette_base(length(domain_names)), domain_names)
    as.data.frame(domain_color) %>% rownames_to_column('domain') %>%
      write.csv(file.path(base_dir, 'specs/domain_color_config.csv'), row.names = FALSE)
  }else{
    site_color <- read_codeset('site_color_custom', 'cc')
    write.csv(site_color, file.path(base_dir, 'specs/site_color_config.csv'), row.names = FALSE)
    
    domain_color <- read_codeset('domain_color_custom', 'cc')
    write.csv(domain_color, file.path(base_dir, 'specs/domain_color_config.csv'), row.names = FALSE)
  }
  
}

#' generate csv with summary of pf process parameters and recs for output function
#'
#' @param site_list - list of sites used to generate output
#' @param visit_list - list of visit types used to generate output
#' @param ms_site - multi- or single-site output, as selected by user
#' @param anom_exp - anomaly or exploratory analysis, as selected by user
#' @param time - logical to denote whether the analysis was conducted over time, as selected by user
#' @param time_span - if time = TRUE, the start and end dates for the time period of interest
#' @param age - csv file that defines age groupings for the cohort, as designated by user. left NULL if age groups
#'              were not desired
#' @param cs - csv file that defines codeset flags for the cohort, as designated by user. left NULL if codeset flags
#'            were not desired
#'
#' @return a csv file with summary information about the parameters used in the `pf_process` function as well as 
#'         recommendations based on those parameters on how to configure the `pf_output_gen` function
#' 
param_csv_summary <- function(site_list,
                              visit_list,
                              ms_site,
                              anom_exp,
                              time,
                              time_span,
                              age,
                              cs){
  
  facet_list <- list()
  
  if(!is.null(age)){facet_list <- facet_list %>% append('age_grp')}
  if(!is.null(cs)){facet_list <- facet_list %>% append('flag')}
  if(length(visit_list) > 1){facet_list <- facet_list %>% append('visit_type')}
  
  dataframe <- data.frame('parameter' = c('site_list', 'visit_types', 'multi_or_single_site',
                                          'anomaly_or_exploratory', 'time', 'time_span', 'facet'),
                          'inputs' = c(paste(site_list, collapse = ','), paste(visit_list, collapse = ','), ms_site, 
                                       anom_exp, time, paste(time_span, collapse = ','), paste(facet_list, collapse = ',')),
                          'description' = c('The list of sites included in the output',
                                            'List of visit types available in the output',
                                            'Multi- or Single-Site output',
                                            'Anomaly or Exploratory output',
                                            'Boolean that defines if the output is to be examined over time',
                                            'The time span over which across-time output is examined',
                                            'List of recommended facets for output based on user input'))
  
  if(!time){
    if(anom_exp == 'anomaly'){
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options','kmeans_clusters'),
                                           'inputs' = c('pf_ms_anom_nt', 'median_site_with0s, median_site_without0s, prop_all_w_fact','2'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact. prop_all_w_fact is the proportion
                                                             of total patients with a fact type.',
                                                             'The number of kmeans clusters recommended as a default. If the function outputs
                                                             an error, this number should be adjusted to fit the appropriate number of clusters
                                                             for the dimensions in your data.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_anom_nt', 'outlier_fact, prop_outlier_fact, outlier_site_fact, prop_outlier_site_fact'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. Each of the statistics defines an outlier as a fact
                                                             count that falls +/- 2 standard deviations from the mean. outlier_fact computes this as an overall
                                                             count of outliers, and prop_outlier_fact is the overall proportion of outliers. outlier_site_fact and
                                                             prop_outlier_site_fact are the same, but they look at the data at a site by site level rather than overall.'))
      }
    }else{
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_exp_nt', 'median_site_with0s, median_site_without0s'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_exp_nt', 'median_site_with0s, median_site_without0s, prop_all_w_fact'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact. prop_all_w_fact is the proportion
                                                             of total patients with a fact type.'))
      }
    }
  }else{
    if(anom_exp == 'anomaly'){
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_anom_at', 'grp_outlier_num, grp_outlier_prop'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. grp_outlier_num is the number
                                                             of patients 2 absolute deviations away from the median. grp_outlier_prop is
                                                             the proportion of patients 2 absolute deviations away from the median.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_anom_at', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }
    }else{
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_exp_at', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'date_breaks_str', 'output options'),
                                           'inputs' = c('pf_ss_exp_at', '1 year', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'For this over time function, the length of time that should be used to divide
                                                                   the output. Weeks, months, and years are the recommended stratification options; the
                                                                   number of those time spans can be changed based on user preference 
                                                                   (i.e. 2 weeks, 6 months, 3 years).',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }
    }
  }
}
