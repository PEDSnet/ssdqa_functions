
########################## DATA PRE PROCESSING #####################################

#' Compute median fact counts by visit & fact type and by site, visit, & fact type
#'
#' @param data_input the list output of `combine_study_facts`
#' @param agegrp boolean that determines whether the output should also
#'               be grouped by age group
#'
#' @return dataframe that contains the total median number of facts for that visit & fact_type
#'         as well as the median number of facts for the site, visit, & fact type for each
#'         study 
#' 
compute_pf_medians <- function(data_input,
                               agegrp=NULL,
                               codeset=NULL) {
  
  
  data_input_cols <- data_input %>% colnames()
  
  if('cohort' %in% data_input_cols) {
    data_input_grp <- 
      data_input %>% group_by(cohort)
  } else {data_input_grp <- data_input}
  
  if(is.data.frame(agegrp)) {data_input_grp <- data_input_grp %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input_grp <- data_input_grp %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_distance_medians_tbl <- 
    data_input_grp %>% 
    group_by(study,
             visit_type,
             domain,
             .add=TRUE) %>% 
    mutate(median_all_with0s=median(var_val),
           median_all_without0s=median(var_val[var_val!=0])) %>% 
    ungroup()
  
  site_distance_final <- 
    data_input_grp %>% 
    left_join(site_distance_medians_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             domain,
             median_all_with0s,
             median_all_without0s,
             .add=TRUE) %>% 
    summarise(n_tot=n(),
              n_w_fact=sum(var_ever),
              median_site_with0s=median(var_val),
              median_site_without0s=median(var_val[var_val!=0])) %>% ungroup() %>% 
    mutate(prop_all_w_fact=round(n_w_fact/n_tot,3))
  
  site_distance_final <- 
    site_distance_final %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x), 0)))
  
  
  site_distance_final
  
}


#' Compute distance from mean
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param agegrp a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a dataframe that summarises the number of patients with fact counts that fall +/- 3 SD away from the mean
#'         both at fact and site + fact levels
#'         
#'         contains columns: person_id, start_date, end_date, fu, site, domain, var_val, var_ever, study,
#'                           visit_type, n_fact, zscore_fact, outlier_fact, prop_outlier_fact, n_site_fact,
#'                           zscore_site_fact, outlier_site_fact, prop_outlier_site_fact
#' 
compute_dist_mean <- function(data_input,
                              agegrp = NULL,
                              codeset = NULL) {
  
  if(is.data.frame(agegrp)) {data_input <- data_input %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input <- data_input %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_dist_means_tbl <- 
    data_input %>% 
    group_by(study,
             visit_type,
             domain,
             .add=TRUE) %>% 
    mutate(n_fact=n(),
           mean_fact=mean(var_val),
           sd_fact=sd(var_val),
           zscore_fact = ((var_val - mean_fact) / sd_fact),
           abs_z = abs(zscore_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_fact = sum(three_sd),
           prop_outlier_fact = round(outlier_fact / n_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_fact, sd_fact))
  
  
  site_dist_means_final <- 
    data_input %>% 
    left_join(site_dist_means_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             domain,
             n_fact,
             outlier_fact,
             prop_outlier_fact,
             .add=TRUE) %>% 
    summarise(n_site_fact=n(),
           mean_site_fact=mean(var_val),
           sd_site_fact=sd(var_val),
           zscore_site_fact = ((var_val - mean_site_fact) / sd_site_fact),
           abs_z = abs(zscore_site_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_site_fact = sum(three_sd),
           prop_outlier_site_fact = round(outlier_site_fact / n_site_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_site_fact, sd_site_fact, zscore_site_fact)) %>% distinct()
  
  site_dist_means_final <- 
    site_dist_means_final %>% replace(is.na(.), 0) 
  
  site_dist_means_final
}


############################ K-means prep ######################################

#' Prepare data for k-means computation
#'
#' @param dat input table generated by `compute_pf_medians`
#' @param age_group a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a matrix with one median value per site and per stratification in select_cols
#' 
prep_kmeans <- function(dat,
                        output,
                        facet_vars) {
  
  kmeans_list <- list()
  
if(!is.null(facet_vars)){
  select_cols <- c('site', 'domain', output, facet_vars)
  
  #facet_list <- dat %>% select(!!sym(facet_var)) %>% distinct() %>% pull()
  
  kmeans_prep <- 
    dat %>% 
    select(!!!syms(select_cols)) %>%
    #filter(!!sym(facet_var) == facet_list[[i]]) %>% 
    pivot_wider(id_cols = site,
                names_from = c(domain, !!!syms(facet_vars)),
                values_from = !!sym(output)) 
  
  kmeans_prep <- 
    kmeans_prep %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
  
  cols <- kmeans_prep %>% select(-site) %>% colnames()
  
  domains <- dat %>% select(domain) %>% distinct() %>% pull()
  
  prep_regex <- function(domains){
    domains = c(domains)
    domain_options = paste(domains, collapse = '|')
    paste0("(", domain_options, ")+_")
  }
  
  regex <- prep_regex(domains)
  
  facet_list <- lapply(cols, function(x){str_remove_all(string = x, pattern = regex)}) %>% unique()
  
  #facet_list <- lapply(cols, function(x){sub("^[^_]*_", "", x)}) %>% unique()
  
  for(i in 1:length(facet_list)){
  
  kmeans_mat <- 
    kmeans_prep %>% 
    column_to_rownames(., var='site')
  
  facet_kmeans <- kmeans_mat[, grepl(facet_list[[i]], names(kmeans_mat))]
  
  kmeans_scaled <- scale(facet_kmeans) 
  
  kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
  
  kmeans_final <- kmeans_scaled
  
  kmeans_list[[i]] <- list(kmeans_scaled,
                           facet_list[[i]])
  }
  
  }else{
    
    select_cols <- c('site', 'domain', output)
      
      kmeans_prep <- 
        dat %>% 
        select(all_of(select_cols)) %>%
        pivot_wider(id_cols = site,
                    names_from = domain,
                    values_from = !!sym(output)) 
      
      kmeans_prep <- 
        kmeans_prep %>% replace(is.na(.), 0) %>% 
        mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
      
      kmeans_mat <- 
        kmeans_prep %>% 
        column_to_rownames(., var='site')
      
      kmeans_scaled <- scale(kmeans_mat) 
      
      kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
      
      kmeans_final <- list(kmeans_scaled,
                           "K-Means Cluster Analysis")
    
  }
  
  kmeans_list
  
  }


#' K-Means Output Generation
#'
#' @param kmeans_list 
#' @param centers 
#' @param facet 
#'
#' @return
#' 
produce_kmeans_output <- function(kmeans_list,
                                  centers
                                  #facet = TRUE
                                  ){
  
  output_list <- list()

  for(i in 1:length(kmeans_list)){
    
    if(ncol(kmeans_list[[i]][[1]]) == 0){next}
    
    set.seed(123)
    k <- kmeans(kmeans_list[[i]][[1]], centers=centers)
    output_list[[i]] <- fviz_cluster(k, data=kmeans_list[[i]][[1]],
                 main = paste0(paste0('K-Means Cluster Analysis: ', kmeans_list[[i]][[2]])),
                 palette = 'Dark2')
    }
  output_list
}


#' FOT Heuristic Check
#'
#' @param target_col 
#' @param tblx 
#' @param site_col 
#' @param time_col 
#' @param facet_var 
#'
#' @return
#' 
fot_check <- function(target_col,
                      tblx=results_tbl('fot_output'),
                      site_col='site',
                      time_col='month_end',
                      facet_var) {
  if(is.null(facet_var)){
    cols_to_keep <- c(eval(site_col),eval(time_col),'check')
    groupedlist1 <- c(time_col)
    groupedlist2 <- c(site_col)
  }else{
    cols_to_keep <- c(eval(site_col),eval(time_col),eval(facet_var),'check')
    groupedlist1 <- c(time_col, facet_var)
    groupedlist2 <- c(site_col, facet_var)
  }
  
  rv <- FALSE
  rv_agg <- FALSE
  #base tbl to make a network wide version of the check
  agg_check <- tblx %>% group_by(!!!syms(groupedlist1)) %>%
    summarise(!!sym(target_col) := sum(!!sym(target_col))) %>%
    ungroup() %>%
    mutate({{site_col}}:='all')  # I need a cheat sheet of when {{x}}/eval(x)/!!sym(x) will actually work
  
  #for (target_check in tblx %>% select(!!sym(check_col)) %>% distinct() %>% pull()) {
  for (target_site in tblx %>% select(!!sym(site_col)) %>% distinct() %>% pull()) {
    foo <- fot_check_calc(tblx %>%
                            filter(site==target_site),
                          site_col='site',
                          time_col,
                          target_col) %>% collect()
    if(!is.logical(rv)){
      rv <- union(rv, foo)
    } else {
      rv <- foo
    }
  }
  
  bar <- fot_check_calc(agg_check,
                        site_col,time_col,target_col) %>%
    select(cols_to_keep) %>% collect()
  if(!is.logical(rv_agg)){
    rv_agg <- union(rv_agg, bar)
  } else {
    rv_agg <- bar
  }
  
  rv_summary <- rv %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect()
  
  rv_summary_allsites <- rv_agg %>%
    filter(site=='all') %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect() %>%
    mutate(site='all')
  
  
  return(list(fot_heuristic= dplyr::union(rv %>% select(cols_to_keep),
                                          rv_agg),
              fot_heuristic_summary=dplyr::union(rv_summary,
                                                 rv_summary_allsites)))
}


#' FOT Heuristic Check Calculation
#'
#' @param tblx 
#' @param site_col 
#' @param time_col 
#' @param target_col 
#'
#' @return
#' 
fot_check_calc <- function(tblx, site_col,time_col, target_col) {
  tblx %>%
    arrange(!! sym(site_col), !! sym(time_col)) %>% 
    mutate(
      lag_1 = lag(!!sym(target_col)),
      lag_1_plus = lead(!!sym(target_col),1),
      # lag_12 = lag(!!sym(target_col),12),
      check_denom = (lag(!!sym(target_col))*.25 +
                       lead(!!sym(target_col),1)*.25)) %>%
    # check_denom()) %>% 
    filter(check_denom!=0) %>%
    mutate(check = !!sym(target_col)/check_denom-1)
}


#' fot table computing distance from "all" check
#'
#' @param fot_check_output first element of list output from `fot_check`
#'
#' @return tbl with the following columns:
#' domain | check_name | month_end | centroid | site | check | distance
#'
#' The `distance` column measures, for each site/domain/check/month combination,
#' the distance between the site's normalized `check` output compared to
#' all sites combined.
#'

check_fot_all_dist <- function(fot_check_output) {
  
  just_all <-
    fot_check_output %>%
    filter(site=='all') %>%
    rename(centroid=check) %>%
    select(-c(site))
  
  combined <-
    just_all %>%
    inner_join(
      fot_check_output
    ) %>% mutate(
      distance=round(check,3)-round(centroid,3)
    )
}

#' Do all FOT checks; 
#' REQUIRES a column in `tblx` to be called `grp`
#' 
#' @param target_col
#' @param tblx
#' @param  site_col defaults to `site`
#' @param time_col defaults to  `month_end`
#' 

check_fot_multisite <- function(tblx,
                                target_col,
                                site_col,
                                time_col, 
                                domain_list,
                                facet_var = NULL) {
  
  final_all <- list()
  
  for(i in 1:length(domain_list)) {
    
    tblx_input <- tblx %>% filter(domain == domain_list[[i]])
    
    fot_output <- fot_check(tblx=tblx_input,
                            target_col=target_col,
                            site_col=site_col,
                            time_col=time_col,
                            facet_var=facet_var)
    
    fot_distance <- check_fot_all_dist(fot_output$fot_heuristic) %>% 
      mutate(grp_check=domain_list[[i]])
    
    final_all[[i]] <- fot_distance
    
  }
  
  letsreduce <- reduce(.x=final_all,
                       .f=dplyr::union)
  
}


#' loops through each medical complexity group
#' and produces interactive graph 
#' using `girafe` package
#' 
#' 
#' @param multisite_tbl a tbl with all sites and a `grp_check` column,
#' as well as a `month_end`, `distance`, `site` columns; output from 
#' the `check_for_multisite` function
#' 
#' @param date_breaks_str the window length for each unit of time
#' on the x-axis
#' 

create_multisite_exp <- function(multisite_tbl,
                                 date_breaks_str,
                                 time_span,
                                 facet_var = NULL,
                                 site_colors_v) {
  
  grp_list <- 
    multisite_tbl %>% 
    select(grp_check) %>% distinct() %>% pull() %>% as.list()
  
  grp_output <- list()
  
  for(i in grp_list) {
    
    if(is.null(facet_var)){
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }else{
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        facet_wrap(facets = eval(facet_var), scales = 'free_y')+
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }
    
    multi_girafe <- 
      girafe(ggobj = multisite_plot_exp,
             width_svg = 8,
             height_svg = 4) %>% 
      girafe_options(opts_tooltip(use_fill=TRUE, css='color:black;', offx=20),
                     opts_hover(css='fill:blue;stroke-width:2;'),
                     opts_hover_inv(css='opacity:0.3'))
    
    
    grp_output[[i]] <- multi_girafe
    #ggplotly(multisite_plot_exp)
  }
  
  grp_output
}

#' output of `check_for_multisite` to look for points where
#' a site is +/- 2 MAD from the median/centoid
#' 
#' 
#' 

produce_multisite_mad <- function(multisite_tbl,
                                  facet_var = NULL,
                                  mad_dev) {
  if(is.null(facet_var)){
    grp1 <- c('start_date', 'grp_check', 'centroid')
    grp2 <- c('site', 'grp_check')
  }else{
    grp1 <- c('start_date', 'grp_check', 'centroid', facet_var)
    grp2 <- c('site', 'grp_check', facet_var)
  }
  
  mad_computation <- 
    multisite_tbl %>% 
    group_by(!!!syms(grp1)) %>% 
    summarise(mad_pt=mad(check, center=centroid)) %>% 
    ungroup() %>% 
    mutate(lower_mad = mad_pt - (abs(mad_pt*mad_dev)),
           upper_mad = mad_pt + (abs(mad_pt*mad_dev)))
  
  full_tbl_outliers <- 
    multisite_tbl %>% ungroup() %>% 
    inner_join(mad_computation) %>% 
    mutate(
      outlier=case_when((distance < lower_mad) | (distance > upper_mad) ~ 1,
                        TRUE ~ 0)
    ) %>% filter(! site=='all')
  
  sites_grp_outliers <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    filter(outlier==1) %>% 
    summarise(grp_outlier_num=n()) %>%  ungroup() 
  
  sites_grp_ct_total <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    summarise(grp_total_num=n()) %>% ungroup()
  
  sites_grp_total <- 
    sites_grp_ct_total %>% 
    left_join(sites_grp_outliers) %>% 
    mutate(grp_outlier_prop = round(grp_outlier_num/grp_total_num,2))
  
  sites_total <- 
    sites_grp_total %>% ungroup() %>% 
    group_by(site) %>% 
    mutate(site_total_num=sum(grp_total_num, na.rm = TRUE),
           site_total_outlier=sum(grp_outlier_num, na.rm = TRUE)) %>% 
    mutate(site_outlier_prop=round(site_total_outlier/site_total_num,2)) %>% 
    rename(grp=grp_check)
  
}

#' generate color schemes for graphs based on user input or automatically
#' 

create_color_scheme <- function(type = 'auto',
                                site_list,
                                domain_list){
  
  if(type == 'auto'){
    site_names <- site_list
    site_palette_base <- colorRampPalette(brewer.pal(8, "Dark2"))
    site_color <- setNames(site_palette_base(length(site_names)), site_names)
    as.data.frame(site_color) %>% rownames_to_column('site') %>%
      write.csv(file.path(base_dir, 'specs/site_color_config.csv'), row.names = FALSE)
    
    domain_names <- domain_list
    domain_palette_base <- colorRampPalette(brewer.pal(8, "Dark2"))
    domain_color <- setNames(domain_palette_base(length(domain_names)), domain_names)
    as.data.frame(domain_color) %>% rownames_to_column('domain') %>%
      write.csv(file.path(base_dir, 'specs/domain_color_config.csv'), row.names = FALSE)
  }else{
    site_color <- read_codeset('site_color_custom', 'cc')
    write.csv(site_color, file.path(base_dir, 'specs/site_color_config.csv'), row.names = FALSE)
    
    domain_color <- read_codeset('domain_color_custom', 'cc')
    write.csv(domain_color, file.path(base_dir, 'specs/domain_color_config.csv'), row.names = FALSE)
  }
  
}

#' generate csv with summary of pf process parameters and recs for output function
#'
#' @param sites 
#' @param visits 
#' @param ms_site 
#' @param anom_exp 
#' @param t 
#' @param ts 
#' @param age 
#' @param cs 
#'
#' @return
#' @export
#'
#' @examples
param_csv_summary <- function(sites,
                              visits,
                              ms_site,
                              anom_exp,
                              t,
                              ts,
                              age,
                              cs){
  
  facet_list <- list()
  
  if(!is.null(age)){facet_list <- facet_list %>% append('age_grp')}
  if(!is.null(cs)){facet_list <- facet_list %>% append('flag')}
  if(length(visits) > 1){facet_list <- facet_list %>% append('visit_type')}
  
  dataframe <- data.frame('parameter' = c('site_list', 'visit_types', 'multi_or_single_site',
                                          'anomaly_or_exploratory', 'time', 'time_span', 'facet'),
                          'inputs' = c(paste(sites, collapse = ','), paste(visits, collapse = ','), ms_site, 
                                       anom_exp, t, paste(ts, collapse = ','), paste(facet_list, collapse = ',')),
                          'description' = c('The list of sites included in the output',
                                            'List of visit types available in the output',
                                            'Multi- or Single-Site output',
                                            'Anomaly or Exploratory output',
                                            'Boolean that defines if the output is to be examined over time',
                                            'The time span over which across-time output is examined',
                                            'List of recommended facets for output based on user input'))
  
  if(!t){
    if(anom_exp == 'anomaly'){
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options','kmeans_clusters'),
                                           'inputs' = c('pf_ms_anom_nt', 'median_site_with0s, median_site_without0s, prop_all_w_fact','2'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact. prop_all_w_fact is the proportion
                                                             of total patients with a fact type.',
                                                             'The number of kmeans clusters recommended as a default. If the function outputs
                                                             an error, this number should be adjusted to fit the appropriate number of clusters
                                                             for the dimensions in your data.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_anom_nt', 'outlier_fact, prop_outlier_fact, outlier_site_fact, prop_outlier_site_fact'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. Each of the statistics defines an outlier as a fact
                                                             count that falls +/- 2 standard deviations from the mean. outlier_fact computes this as an overall
                                                             count of outliers, and prop_outlier_fact is the overall proportion of outliers. outlier_site_fact and
                                                             prop_outlier_site_fact are the same, but they look at the data at a site by site level rather than overall.'))
      }
    }else{
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_exp_nt', 'median_site_with0s, median_site_without0s'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_exp_nt', 'median_site_with0s, median_site_without0s, prop_all_w_fact'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_site_with0s is the median number of patients
                                                             with a fact, including patients without the fact. median_site_without0s is the median
                                                             number of patients with a fact, excluding patients without the fact. prop_all_w_fact is the proportion
                                                             of total patients with a fact type.'))
      }
    }
  }else{
    if(anom_exp == 'anomaly'){
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_anom_at', 'grp_outlier_num, grp_outlier_prop'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. grp_outlier_num is the number
                                                             of patients 2 absolute deviations away from the median. grp_outlier_prop is
                                                             the proportion of patients 2 absolute deviations away from the median.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ss_anom_at', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }
    }else{
      if(ms_site == 'multi'){
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'output options'),
                                           'inputs' = c('pf_ms_exp_at', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }else{
        dataframe <- dataframe %>% add_row('parameter' = c('output_function', 'date_breaks_str', 'output options'),
                                           'inputs' = c('pf_ss_exp_at', '1 year', 'median_fact_ct, sum_fact_ct'),
                                           'description' = c('The function for output generation that will be run based on user input',
                                                             'For this over time function, the length of time that should be used to divide
                                                                   the output. Weeks, months, and years are the recommended stratification options; the
                                                                   number of those time spans can be changed based on user preference 
                                                                   (i.e. 2 weeks, 6 months, 3 years).',
                                                             'Options for statistics to use in the output. median_fact_ct is the median
                                                             number of facts per domain in the specified time period. sum_fact_ct is the sum of
                                                             facts per domain in the specified time period.'))
      }
    }
  }
}
