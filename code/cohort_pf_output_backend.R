
########################## DATA PRE PROCESSING #####################################

#' Compute median fact counts by visit & fact type and by site, visit, & fact type
#'
#' @param data_input the list output of `combine_study_facts`
#' @param agegrp boolean that determines whether the output should also
#'               be grouped by age group
#'
#' @return dataframe that contains the total median number of facts for that visit & fact_type
#'         as well as the median number of facts for the site, visit, & fact type for each
#'         study 
#' 
compute_pf_medians <- function(data_input,
                               agegrp=NULL,
                               codeset=NULL) {
  
  
  data_input_cols <- data_input %>% colnames()
  
  if('cohort' %in% data_input_cols) {
    data_input_grp <- 
      data_input %>% group_by(cohort)
  } else {data_input_grp <- data_input}
  
  if(is.data.frame(agegrp)) {data_input_grp <- data_input_grp %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input_grp <- data_input_grp %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_distance_medians_tbl <- 
    data_input_grp %>% 
    group_by(study,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(median_all_with0s=median(var_val),
           median_all_without0s=median(var_val[var_val!=0])) %>% 
    ungroup()
  
  site_distance_final <- 
    data_input_grp %>% 
    left_join(site_distance_medians_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             var_name,
             median_all_with0s,
             median_all_without0s,
             .add=TRUE) %>% 
    summarise(n_tot=n(),
              n_w_fact=sum(var_ever),
              median_site_with0s=median(var_val),
              median_site_without0s=median(var_val[var_val!=0])) %>% ungroup() %>% 
    mutate(prop_all_w_fact=round(n_w_fact/n_tot,3))
  
  site_distance_final <- 
    site_distance_final %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x), 0)))
  
  
  site_distance_final
  
}


#' Compute distance from mean
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param agegrp a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a dataframe that summarises the number of patients with fact counts that fall +/- 3 SD away from the mean
#'         both at fact and site + fact levels
#'         
#'         contains columns: person_id, start_date, end_date, fu, site, var_name, var_val, var_ever, study,
#'                           visit_type, n_fact, zscore_fact, outlier_fact, prop_outlier_fact, n_site_fact,
#'                           zscore_site_fact, outlier_site_fact, prop_outlier_site_fact
#' 
compute_dist_mean <- function(data_input,
                              agegrp = NULL,
                              codeset = NULL) {
  
  if(is.data.frame(agegrp)) {data_input <- data_input %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input <- data_input %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_dist_means_tbl <- 
    data_input %>% 
    group_by(study,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(n_fact=n(),
           mean_fact=mean(var_val),
           sd_fact=sd(var_val),
           zscore_fact = ((var_val - mean_fact) / sd_fact),
           abs_z = abs(zscore_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_fact = sum(three_sd),
           prop_outlier_fact = round(outlier_fact / n_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_fact, sd_fact))
  
  
  site_dist_means_final <- 
    data_input %>% 
    left_join(site_dist_means_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(n_site_fact=n(),
           mean_site_fact=mean(var_val),
           sd_site_fact=sd(var_val),
           zscore_site_fact = ((var_val - mean_site_fact) / sd_site_fact),
           abs_z = abs(zscore_site_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_site_fact = sum(three_sd),
           prop_outlier_site_fact = round(outlier_site_fact / n_site_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_site_fact, sd_site_fact))
  
  site_dist_means_final <- 
    site_dist_means_final %>% replace(is.na(.), 0) 
  
  site_dist_means_final
}


########################## PRE VISUALIZATION PROCESSING #####################################

### One table per site & outcome_var

#' Create list input for single site output
#'
#' @param data_tbl input table generated by `compute_pf_medians`
#' @param outcome_var the outcome variable of interest from `data_tbl`
#'
#' @return a list of tables, one for each site in data_tbl, plus the relevant outcome variable as a string
#'
create_list_input_sepsites <- function(data_tbl,
                                       site_colors,
                                       outcome_var) {
  
  site_list <- 
    data_tbl %>% select(site) %>% distinct() %>% pull() %>% as.list()
  
  final_list <- list()
  
  for(i in 1:length(site_list)) {
    
    data_tbl_c <- as.data.frame(site_colors) %>%
      rownames_to_column('site') %>% as_tibble() %>% 
      filter(site == site_list[[i]]) %>%
      left_join(data_tbl)
    
    elem1 <- data_tbl_c %>% filter(site==site_list[[i]])
    elem2 <- outcome_var
    
    args_list <- 
      list('data_tbl' = elem1,
           'outcome' = elem2)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}


### One table per visit_type & var_name_list element, w/ argument for facet_var_nm

#' @param data_tbl --- the data tbl that will be used for the `prod_bar_facet` function
#' @param visit_type_nm --- the visit type to produce output for
#' 
#' @return a list of tables, one for each domain in a provided list, plus the provided var_name_label and
#'         facet_var as strings
#' 
create_list_input_facet_sepvarname <- function(data_tbl,
                                               facet_var_nm,
                                               site_colors,
                                               site_name_list) {
  
  site_list <- 
    site_name_list
  
  final_list <- list()
  
  for(i in 1:length(site_list)) {
    
    data_tbl_c <- as.data.frame(site_colors) %>%
      rownames_to_column('site') %>%
      filter(site == site_list[[i]]) %>%
      left_join(data_tbl)
    
    elem1 <- data_tbl_c
    elem2 <- site_list[[i]]
    
    args_list <- 
      list('data_tbl' = elem1,
           'site_name_label' = elem2,
           'facet_var' = facet_var_nm)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}

############################ K-means prep ######################################

#' Prepare data for k-means computation
#'
#' @param dat input table generated by `compute_pf_medians`
#' @param age_group a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a matrix with one median value per site and per stratification in select_cols
#' 
prep_kmeans <- function(dat,
                        facet_var) {
  
  kmeans_list <- list()
  
if(!is.null(facet_var)){
  select_cols <- c('site', 'var_name', 'median_site_without0s', facet_var)
  
  facet_list <- dat %>% select(!!sym(facet_var)) %>% distinct() %>% pull()
  
  for(i in 1:length(facet_list)){
  
  kmeans_prep <- 
    dat %>% 
    select(!!!syms(select_cols)) %>%
    filter(!!sym(facet_var) == facet_list[[i]]) %>% 
    pivot_wider(id_cols = site,
                names_from = var_name,
                values_from = median_site_without0s) 
  
  kmeans_prep <- 
    kmeans_prep %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
  
  kmeans_mat <- 
    kmeans_prep %>% 
    column_to_rownames(., var='site')
  
  kmeans_scaled <- scale(kmeans_mat) 
  
  kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
  
  kmeans_list[[i]] <- list(kmeans_scaled,
                           facet_list[[i]])
  }
  
  }else{
    
    select_cols <- c('site', 'var_name', 'median_site_without0s')
      
      kmeans_prep <- 
        dat %>% 
        select(all_of(select_cols)) %>%
        pivot_wider(id_cols = site,
                    names_from = var_name,
                    values_from = median_site_without0s) 
      
      kmeans_prep <- 
        kmeans_prep %>% replace(is.na(.), 0) %>% 
        mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
      
      kmeans_mat <- 
        kmeans_prep %>% 
        column_to_rownames(., var='site')
      
      kmeans_scaled <- scale(kmeans_mat) 
      
      kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
      
      kmeans_list <- list(kmeans_scaled,
                          'Multi-Site Non-Stratified')
    
  }
  
  kmeans_list
  
  }


#' K-Means Output Generation
#'
#' @param kmeans_list 
#' @param centers 
#' @param facet 
#'
#' @return
#' 
produce_kmeans_output <- function(kmeans_list,
                                  centers,
                                  facet = TRUE){
  
  output_list <- list()
  
  if(facet){
  
  for(i in 1:length(kmeans_list)){
    
    set.seed(123)
    k <- kmeans(kmeans_list[[i]][[1]], centers=centers)
    output <- fviz_cluster(k, data=kmeans_list[[i]][[1]], 
                 main = paste0('K-Means Cluster Analysis: ', kmeans_list[[i]][[2]]))
    
    output_list[[paste0(kmeans_list[[i]][[2]])]] <- output
    
  }
  }else{
    
    set.seed(123)
    k <- kmeans(kmeans_list[[1]], centers=centers)
    output <- fviz_cluster(k, data=kmeans_list[[1]], 
                           main = paste0('K-Means Cluster Analysis: ', kmeans_list[[2]]))
    
    output_list[[paste0(kmeans_list[[2]])]] <- output
      
    }
  
  output_list
  
}


############################# GENERATE OUTPUT ##################################

#' ******Sep Sites Bar Output******

#' Function to loop through table and apply function `prod_bar_sepsites`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepsites`
#' @param thresh boolean indicator of whether to include thresholds on plot
#' 

create_sepsite_output <- function(list_name,
                                  facet_vars) {
  
  output_sepsites <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- prod_bar_sepsites(data_tbl=list_name[[i]][[1]],
                               outcome=list_name[[i]][[2]],
                               facet_vars=facet_vars)
    
    output_sepsites[[i]] <- final
  }
  
  output_sepsites
  
}

#' produces output for a given outcome (proportion of visits, median number, etc)
#' for a given data output, faceted by visit type. Side bar plots, with each bar
#' the pf_domain, or var_name. 
#' 
#' This function relies on one of the filters being BY SITE. This is a site-specific
#' output measure.
#' 
#' @param data_tbl the data tbl
#' @param outcome the outcome, as a string; must be the column name in `data_tbl`
#' @param incl_thresh boolean indicator of whether to overlay thresholds on the plot
#' 
#' @return see description; ggcharts style output
#' 

prod_bar_sepsites <- function(data_tbl,
                              outcome,
                              facet_vars) {
  
  site_nm <- data_tbl %>% select(site) %>% distinct() %>% pull()
  
  color <- data_tbl %>% filter(site == site_nm) %>% select(site_colors) %>% 
    distinct() %>% pull()

    bar_chart(data_tbl %>% filter(site == site_nm), x=var_name_lab,y=!! sym(outcome), facet = facet_vars, bar_color=color) +
      ggtitle(paste0(site_nm, ' : Median Facts per Patient'))
}


#' ******Facet Var Output******

# Function to loop through table and apply function `prod_bar_facet`

create_facet_graphs_byvarname <- function(list_name) {
  
  output_varname <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- prod_bar_facet(data_tbl=list_name[[i]][[1]],
                            site_name_label=list_name[[i]][[2]],
                            facet_var_nm=list_name[[i]][[3]])
    
    output_varname[[i]] <- final
    
  }
  
  output_varname
}

#' stratifies bar graphs by a particular variable
#' 
#' *** NOTE THAT THIS DATA INPUT SHOULD ALREADY FILTER BY VISIT TYPE FROM THE INPUT;
#' IF NOT, ENSURE THAT THE DATA TBL ARG FILTERS BY VISIT TYPE *** 
#' 
#' 
#' @param data_tbl the data tbl
#' @param var_name_label the outcome, as a string; must be the column name in `data_tbl`
#' @param facet_var the variable to facet by (in our use case, `age_ce_grp`)
#' 
#' @return 
#' 


prod_bar_facet <- function(data_tbl,
                           site_name_label,
                           facet_var_nm) {
  
  color <- data_tbl %>% filter(site == site_name_label) %>% select(site_colors) %>% 
    distinct() %>% pull()
  
  bar_chart(data_tbl %>% filter(site==site_name_label), 
            facet=!! sym(facet_var_nm), x=var_name,y=median_site_without0s,bar_color=color) +
    ggtitle(paste0(site_name_label, ', ', facet_var_nm, ' : Median Facts per Patient'))
  
}




#' FOT Heuristic Check
#'
#' @param target_col 
#' @param tblx 
#' @param site_col 
#' @param time_col 
#' @param facet_var 
#'
#' @return
#' 
fot_check <- function(target_col,
                      tblx=results_tbl('fot_output'),
                      site_col='site',
                      time_col='month_end',
                      facet_var) {
  if(is.null(facet_var)){
    cols_to_keep <- c(eval(site_col),eval(time_col),'check')
    groupedlist1 <- c(time_col)
    groupedlist2 <- c(site_col)
  }else{
    cols_to_keep <- c(eval(site_col),eval(time_col),eval(facet_var),'check')
    groupedlist1 <- c(time_col, facet_var)
    groupedlist2 <- c(site_col, facet_var)
  }
  
  rv <- FALSE
  rv_agg <- FALSE
  #base tbl to make a network wide version of the check
  agg_check <- tblx %>% group_by(!!!syms(groupedlist1)) %>%
    summarise(!!sym(target_col) := sum(!!sym(target_col))) %>%
    ungroup() %>%
    mutate({{site_col}}:='all')  # I need a cheat sheet of when {{x}}/eval(x)/!!sym(x) will actually work
  
  #for (target_check in tblx %>% select(!!sym(check_col)) %>% distinct() %>% pull()) {
  for (target_site in tblx %>% select(!!sym(site_col)) %>% distinct() %>% pull()) {
    foo <- fot_check_calc(tblx %>%
                            filter(site==target_site),
                          site_col='site',
                          time_col,
                          target_col) %>% collect()
    if(!is.logical(rv)){
      rv <- union(rv, foo)
    } else {
      rv <- foo
    }
  }
  
  bar <- fot_check_calc(agg_check,
                        site_col,time_col,target_col) %>%
    select(cols_to_keep) %>% collect()
  if(!is.logical(rv_agg)){
    rv_agg <- union(rv_agg, bar)
  } else {
    rv_agg <- bar
  }
  
  rv_summary <- rv %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect()
  
  rv_summary_allsites <- rv_agg %>%
    filter(site=='all') %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect() %>%
    mutate(site='all')
  
  
  return(list(fot_heuristic= dplyr::union(rv %>% select(cols_to_keep),
                                          rv_agg),
              fot_heuristic_summary=dplyr::union(rv_summary,
                                                 rv_summary_allsites)))
}


#' FOT Heuristic Check Calculation
#'
#' @param tblx 
#' @param site_col 
#' @param time_col 
#' @param target_col 
#'
#' @return
#' 
fot_check_calc <- function(tblx, site_col,time_col, target_col) {
  tblx %>%
    arrange(!! sym(site_col), !! sym(time_col)) %>% 
    mutate(
      lag_1 = lag(!!sym(target_col)),
      lag_1_plus = lead(!!sym(target_col),1),
      # lag_12 = lag(!!sym(target_col),12),
      check_denom = (lag(!!sym(target_col))*.25 +
                       lead(!!sym(target_col),1)*.25)) %>%
    # check_denom()) %>% 
    filter(check_denom!=0) %>%
    mutate(check = !!sym(target_col)/check_denom-1)
}


#' fot table computing distance from "all" check
#'
#' @param fot_check_output first element of list output from `fot_check`
#'
#' @return tbl with the following columns:
#' domain | check_name | month_end | centroid | site | check | distance
#'
#' The `distance` column measures, for each site/domain/check/month combination,
#' the distance between the site's normalized `check` output compared to
#' all sites combined.
#'

check_fot_all_dist <- function(fot_check_output) {
  
  just_all <-
    fot_check_output %>%
    filter(site=='all') %>%
    rename(centroid=check) %>%
    select(-c(site))
  
  combined <-
    just_all %>%
    inner_join(
      fot_check_output
    ) %>% mutate(
      distance=round(check,3)-round(centroid,3)
    )
}

#' Do all FOT checks; 
#' REQUIRES a column in `tblx` to be called `grp`
#' 
#' @param target_col
#' @param tblx
#' @param  site_col defaults to `site`
#' @param time_col defaults to  `month_end`
#' 

check_fot_multisite <- function(tblx,
                                target_col,
                                site_col,
                                time_col, 
                                domain_list,
                                facet_var = NULL) {
  
  final_all <- list()
  
  for(i in 1:length(domain_list)) {
    
    tblx_input <- tblx %>% filter(domain == domain_list[[i]])
    
    fot_output <- fot_check(tblx=tblx_input,
                            target_col=target_col,
                            site_col=site_col,
                            time_col=time_col,
                            facet_var=facet_var)
    
    fot_distance <- check_fot_all_dist(fot_output$fot_heuristic) %>% 
      mutate(grp_check=domain_list[[i]])
    
    final_all[[i]] <- fot_distance
    
  }
  
  letsreduce <- reduce(.x=final_all,
                       .f=dplyr::union)
  
}


#' loops through each medical complexity group
#' and produces interactive graph 
#' using `girafe` package
#' 
#' 
#' @param multisite_tbl a tbl with all sites and a `grp_check` column,
#' as well as a `month_end`, `distance`, `site` columns; output from 
#' the `check_for_multisite` function
#' 
#' @param date_breaks_str the window length for each unit of time
#' on the x-axis
#' 

create_multisite_exp <- function(multisite_tbl,
                                 date_breaks_str,
                                 time_span,
                                 facet_var = NULL,
                                 site_colors_v) {
  
  grp_list <- 
    multisite_tbl %>% 
    select(grp_check) %>% distinct() %>% pull() %>% as.list()
  
  grp_output <- list()
  
  for(i in grp_list) {
    
    if(is.null(facet_var)){
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }else{
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < time_span[2],start_date > time_span[1]),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        facet_wrap(facets = eval(facet_var), scales = 'free_y')+
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }
    
    multi_girafe <- 
      girafe(ggobj = multisite_plot_exp,
             width_svg = 8,
             height_svg = 4) %>% 
      girafe_options(opts_tooltip(use_fill=TRUE, css='color:black;', offx=20),
                     opts_hover(css='fill:blue;stroke-width:2;'),
                     opts_hover_inv(css='opacity:0.3'))
    
    
    grp_output[[i]] <- multi_girafe
    #ggplotly(multisite_plot_exp)
  }
  
  grp_output
}

#' output of `check_for_multisite` to look for points where
#' a site is +/- 2 MAD from the median/centoid
#' 
#' 
#' 

produce_multisite_mad <- function(multisite_tbl,
                                  facet_var = NULL,
                                  mad_dev) {
  if(is.null(facet_var)){
    grp1 <- c('start_date', 'grp_check', 'centroid')
    grp2 <- c('site', 'grp_check')
  }else{
    grp1 <- c('start_date', 'grp_check', 'centroid', facet_var)
    grp2 <- c('site', 'grp_check', facet_var)
  }
  
  mad_computation <- 
    multisite_tbl %>% 
    group_by(!!!syms(grp1)) %>% 
    summarise(mad_pt=mad(check, center=centroid)) %>% 
    ungroup() %>% 
    mutate(lower_mad = mad_pt - (abs(mad_pt*mad_dev)),
           upper_mad = mad_pt + (abs(mad_pt*mad_dev)))
  
  full_tbl_outliers <- 
    multisite_tbl %>% ungroup() %>% 
    inner_join(mad_computation) %>% 
    mutate(
      outlier=case_when((distance < lower_mad) | (distance > upper_mad) ~ 1,
                        TRUE ~ 0)
    ) %>% filter(! site=='all')
  
  sites_grp_outliers <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    filter(outlier==1) %>% 
    summarise(grp_outlier_num=n()) %>%  ungroup() 
  
  sites_grp_ct_total <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    summarise(grp_total_num=n()) %>% ungroup()
  
  sites_grp_total <- 
    sites_grp_ct_total %>% 
    left_join(sites_grp_outliers) %>% 
    mutate(grp_outlier_prop = round(grp_outlier_num/grp_total_num,2))
  
  sites_total <- 
    sites_grp_total %>% ungroup() %>% 
    group_by(site) %>% 
    mutate(site_total_num=sum(grp_total_num),
           site_total_outlier=sum(grp_outlier_num)) %>% 
    mutate(site_outlier_prop=round(site_total_outlier/site_total_num,2)) %>% 
    rename(grp=grp_check)
  
}
