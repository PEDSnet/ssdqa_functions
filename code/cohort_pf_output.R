
########################## DATA PRE PROCESSING #####################################

#' Compute median fact counts by visit & fact type and by site, visit, & fact type
#'
#' @param data_input the list output of `combine_study_facts`
#' @param agegrp boolean that determines whether the output should also
#'               be grouped by age group
#'
#' @return dataframe that contains the total median number of facts for that visit & fact_type
#'         as well as the median number of facts for the site, visit, & fact type for each
#'         study 
#' 
compute_pf_medians <- function(data_input,
                               agegrp=NULL,
                               codeset=NULL) {
  
  
  data_input_cols <- data_input %>% colnames()
  
  if('cohort' %in% data_input_cols) {
    data_input_grp <- 
      data_input %>% group_by(cohort)
  } else {data_input_grp <- data_input}
  
  if(is.data.frame(agegrp)) {data_input_grp <- data_input_grp %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input_grp <- data_input_grp %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_distance_medians_tbl <- 
    data_input_grp %>% 
    group_by(study,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(median_all_with0s=median(var_val),
           median_all_without0s=median(var_val[var_val!=0])) %>% 
    ungroup()
  
  site_distance_final <- 
    data_input_grp %>% 
    left_join(site_distance_medians_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             var_name,
             median_all_with0s,
             median_all_without0s,
             .add=TRUE) %>% 
    summarise(n_tot=n(),
              n_w_fact=sum(var_ever),
              median_site_with0s=median(var_val),
              median_site_without0s=median(var_val[var_val!=0])) %>% ungroup() %>% 
    mutate(prop_all_w_fact=round(n_w_fact/n_tot,3))
  
  site_distance_final <- 
    site_distance_final %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x), 0)))
  
  
  site_distance_final
  
}


#' Compute distance from mean
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param agegrp a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a dataframe that summarises the number of patients with fact counts that fall +/- 3 SD away from the mean
#'         both at fact and site + fact levels
#'         
#'         contains columns: person_id, start_date, end_date, fu, site, var_name, var_val, var_ever, study,
#'                           visit_type, n_fact, zscore_fact, outlier_fact, prop_outlier_fact, n_site_fact,
#'                           zscore_site_fact, outlier_site_fact, prop_outlier_site_fact
#' 
compute_dist_mean <- function(data_input,
                              agegrp = NULL,
                              codeset = NULL) {
  
  if(is.data.frame(agegrp)) {data_input <- data_input %>% group_by(age_grp,.add=TRUE) %>% 
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  if(is.data.frame(codeset)) {data_input <- data_input %>% group_by(flag,.add=TRUE) %>%
    mutate(flag = ifelse(is.na(flag), 'None', flag))}
  
  site_dist_means_tbl <- 
    data_input %>% 
    group_by(study,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(n_fact=n(),
           mean_fact=mean(var_val),
           sd_fact=sd(var_val),
           zscore_fact = ((var_val - mean_fact) / sd_fact),
           abs_z = abs(zscore_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_fact = sum(three_sd),
           prop_outlier_fact = round(outlier_fact / n_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_fact, sd_fact))
  
  
  site_dist_means_final <- 
    data_input %>% 
    left_join(site_dist_means_tbl) %>% 
    group_by(study,
             site,
             visit_type,
             var_name,
             .add=TRUE) %>% 
    mutate(n_site_fact=n(),
           mean_site_fact=mean(var_val),
           sd_site_fact=sd(var_val),
           zscore_site_fact = ((var_val - mean_site_fact) / sd_site_fact),
           abs_z = abs(zscore_site_fact),
           three_sd = case_when(abs_z > 2L ~ 1L,
                                     TRUE ~ 0L),
           outlier_site_fact = sum(three_sd),
           prop_outlier_site_fact = round(outlier_site_fact / n_site_fact, 3)) %>% 
    ungroup() %>%
    select(-c(three_sd, abs_z, mean_site_fact, sd_site_fact))
  
  site_dist_means_final <- 
    site_dist_means_final %>% replace(is.na(.), 0) 
  
  site_dist_means_final
}


########################## PRE VISUALIZATION PROCESSING #####################################

### One table per site & outcome_var

#' Create list input for single site output
#'
#' @param data_tbl input table generated by `compute_pf_medians`
#' @param outcome_var the outcome variable of interest from `data_tbl`
#'
#' @return a list of tables, one for each site in data_tbl, plus the relevant outcome variable as a string
#'
create_list_input_sepsites <- function(data_tbl,
                                       outcome_var) {
  
  site_list <- 
    data_tbl %>% select(site) %>% distinct() %>% pull() %>% as.list()
  
  final_list <- list()
  
  for(i in 1:length(site_list)) {
    elem1 <- data_tbl %>% filter(site==site_list[[i]])
    elem2 <- outcome_var
    
    args_list <- 
      list('data_tbl' = elem1,
           'outcome' = elem2)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}


### One table per domain for the specified visit_type_nm

#' @param data_tbl --- the data tbl that will be used for the `prod_bar_sepvisittype` function
#' @param visit_type_nm --- the visit type to produce output for
#' 
#' @return a list of tables, one for each domain in a provided list, plus the relevant var_name_label as a string
#' 
create_list_input_sepvisittype <- function(data_tbl,
                                           visit_type_nm) {
  
  domain_config_domains <- 
    domain_config %>% select(domain) %>% pull() %>% as.list()
  
  final_list <- list()
  
  thresholds <- read_codeset('thresholds', col_types='ccd')
  
  for(i in 1:length(domain_config_domains)) {
    elem1 <- data_tbl %>% filter(visit_type==visit_type_nm) %>%
      left_join(thresholds, by = c('visit_type', 'var_name'='domain'))
    elem2 <- domain_config_domains[[i]]
    
    args_list <- 
      list('data_tbl' = elem1,
           'var_name_label' = elem2)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}


### One table per visit_type & var_name_list element, w/ argument for facet_var_nm

#' @param data_tbl --- the data tbl that will be used for the `prod_bar_facet` function
#' @param visit_type_nm --- the visit type to produce output for
#' 
#' @return a list of tables, one for each domain in a provided list, plus the provided var_name_label and
#'         facet_var as strings
#' 
create_list_input_facet_sepvarname <- function(data_tbl,
                                               facet_var_nm,
                                               var_name_list) {
  
  domain_list <- 
    var_name_list
  
  final_list <- list()
  
  for(i in 1:length(domain_list)) {
    elem1 <- data_tbl
    elem2 <- domain_list[[i]]
    
    args_list <- 
      list('data_tbl' = elem1,
           'var_name_label' = elem2,
           'facet_var' = facet_var_nm)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}


### one table per site for the pyramid graphs

create_list_input_sepsites_pyr <- function(data_tbl) {
  
  site_list <- 
    data_tbl %>% select(site) %>% distinct() %>% pull() %>% as.list()
  
  final_list <- list()
  
  for(i in 1:length(site_list)) {
    elem1 <- data_tbl %>% filter(site==site_list[[i]])
    
    args_list <- 
      list('data_tbl' = elem1)
    
    final_list[[i]] <- args_list
    
  }
  
  final_list
}


############################## LOF PREP #######################################

#' iterate through all sites `compute_lof`
#' for all sites
#' 
#' @param input_tbls the input generated from `compute_lof`
#' @param var_list_args the list of arguments that include `var_name` and associated hex color
#' @param 
#' 

#' Function to loop through table and apply function `prod_bar_sepsites`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepsites`
#' 

create_sepsite_output_lof <- function(input_tbls,
                                      var_list_arg) {
  
  output_sepsites <- list()
  
  for(i in 1:length(input_tbls)) {
    
    final <- compute_lof(data_tbl=input_tbls[[i]],
                         var_list_arg=var_list_arg)
    
    final_reduce <- reduce(.x=final,
                           .f=dplyr::union) 
    
    output_sepsites[[i]] <- final
  }
  
  output_sepsites
  
}

#' @param var_list_arg two element list, with the firstbeing the variable name
#' and the second being the associated hex color for the graph output
#' @param data_tbl the data tbl to perform LOF on 
#' 
##' @param var_list list of lists with the following elements: 
##'   list(list(`first` = list(`domain1`, `hex_color1`),
##'                       list(`domain2`, `hex_color2`), etc))
##'                       

##' 
compute_lof <- function(data_tbl,
                        var_list_arg,
                        remove_outliers = TRUE) {
  
  var_list <- var_list_arg
  # var_list = list('first' = list('conditions_all', '#a5879e'),
  #                 'second' = list('anthropometrics','#e52b50'),
  #                 'third' = list('labs', '#6e9f65'))
  final_lof <- list()
  #colors_final <- c()
  
  for(i in 1:length(var_list)) {
    
    message(paste0('Starting ',var_list[[i]][[1]]))
    
    var_nm <- var_list[[i]][[1]]
    
    data_tbl_site <- data_tbl %>% select(site) %>% distinct() %>% pull()
    
    lof_tbl <- data_tbl %>% 
      filter(var_name == var_nm) %>% 
      filter(var_ever == 1) %>% 
      group_by(visit_type) %>% 
      arrange(.by_group = TRUE) %>% ungroup() %>% distinct() 
    
    k_val <- gen_k(lof_tbl)
    
    lof_setup_scale <- as.data.frame(scale(lof_tbl %>% select(var_val))) 
    
    lof_t <- lof(lof_setup_scale, k=k_val)
    
    lof_tbl$lof_val <- lof_t
    
    lof_tbl <- 
      lof_tbl %>% 
      filter(!is.infinite(lof_val),
             !is.na(lof_val),
             !is.nan(lof_val))
    
    color_final <- var_list[[i]][[2]]
    
    quantiles <- quantile(lof_tbl$lof_val, probs=c(0.1, 0.8, 0.9, 0.95, 0.99))
    
    final_lof[[i]] <- lof_tbl %>% mutate(hex_color=color_final) %>% 
      mutate(tenth_percentile=quantiles[[1]],
             eightieth_percentile=quantiles[[2]],
             ninetieth_percentile=quantiles[[3]],
             ninetyfifth_percentile=quantiles[[4]],
             ninetyninth_percentile=quantiles[[5]])
    
  }
  
  final_lof
  
}


#' Get general k value for LOF computation
#'
#' @param dat dataframe with one row for each variable in each visit type
#'
#' @return one value that will be used as the k value in `compute_lof`
#' 
gen_k <- function(dat) {
  
  dat_grprows <- 
    dat %>% filter(var_ever == 1) %>% 
    group_by(
      visit_type
    ) %>% summarise(ct=n())
  
  k_val <- 
    dat_grprows %>% 
    ungroup() %>% 
    summarise(median_ct=median(ct)) %>% 
    mutate(k_val=sqrt(floor(0.10*median_ct))) %>% 
    mutate(k_val=case_when(k_val < 30 ~ 30,
                           k_val > 60 ~ 60,
                           TRUE ~ k_val)) %>% 
    select(k_val) %>% pull()
}


##' creates list of input for the `compute_lof` function
##' @param data_tbl the data_tbl --- should not filter by site (will be done in the function);
##' the `compute_lof` function will iterate through the var_name, so this should also 
##' not be filtered by that or the visit type, since visit_type is part of the `lof` computation. 


create_lof_input <- function(data_tbl){
  
  site_list <- 
    data_tbl %>% select(site) %>% distinct() %>% pull() %>% as.list()
  
  
  
  final_list <- list()
  
  for(i in 1:length(site_list)) {
    
    # tmp_list <- list()
    elem1 <- data_tbl %>% filter(site==site_list[[i]])
    final_list[[i]] <- elem1
    
  }
  
  final_list
}

#' Reduce the nested list from `create_sepsite_output_lof`
#'
#' @param lof_comp_output nested list output from `create_sepsite_output_lof`
#'
#' @return a list of dataframes, each dataframe belonging to one site with the 
#'         previously separated fact type tables combined into one
#' 
sepsite_lof_reduce <- function(lof_comp_output) {
  
  output_sepsite <- list()
  
  for(i in 1:length(lof_comp_output)) {
    
    reduce_site_lofs <- reduce(.x=lof_comp_output[[i]],
                               .f=dplyr::union)
    
    output_sepsite[[i]] <- reduce_site_lofs
  }
  
  output_sepsite %>% reduce(dplyr::union)
  
}

############################ K-means prep ######################################

#' Prepare data for k-means computation
#'
#' @param dat input table generated by `compute_pf_medians`
#' @param age_group a csv file with user designated age groupings, based on age at cohort entry
#' @param codeset a csv file with user designated cohort flags based on a user provided codeset
#'
#' @return a matrix with one median value per site and per stratification in select_cols
#' 
prep_kmeans <- function(dat,
                        facet_var) {
  
  kmeans_list <- list()
  
if(!is.null(facet_var)){
  select_cols <- c('site', 'var_name', 'median_site_without0s', facet_var)
  
  facet_list <- dat %>% select(!!sym(facet_var)) %>% distinct() %>% pull()
  
  for(i in 1:length(facet_list)){
  
  kmeans_prep <- 
    dat %>% 
    select(!!!syms(select_cols)) %>%
    filter(!!sym(facet_var) == facet_list[[i]]) %>% 
    pivot_wider(id_cols = site,
                names_from = var_name,
                values_from = median_site_without0s) 
  
  kmeans_prep <- 
    kmeans_prep %>% replace(is.na(.), 0) %>% 
    mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
  
  kmeans_mat <- 
    kmeans_prep %>% 
    column_to_rownames(., var='site')
  
  kmeans_scaled <- scale(kmeans_mat) 
  
  kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
  
  kmeans_list[[i]] <- list(kmeans_scaled,
                           facet_list[[i]])
  }
  
  }else{
    
    select_cols <- c('site', 'var_name', 'median_site_without0s')
      
      kmeans_prep <- 
        dat %>% 
        select(all_of(select_cols)) %>%
        pivot_wider(id_cols = site,
                    names_from = var_name,
                    values_from = median_site_without0s) 
      
      kmeans_prep <- 
        kmeans_prep %>% replace(is.na(.), 0) %>% 
        mutate(across(everything(), ~ replace(.x, is.nan(.x),0)))
      
      kmeans_mat <- 
        kmeans_prep %>% 
        column_to_rownames(., var='site')
      
      kmeans_scaled <- scale(kmeans_mat) 
      
      kmeans_scaled[, !colSums(!is.finite(kmeans_scaled))]
      
      kmeans_list <- list(kmeans_scaled,
                          'Multi-Site Non-Stratified')
    
  }
  
  kmeans_list
  
  }


produce_kmeans_output <- function(kmeans_list,
                                  centers,
                                  facet = TRUE){
  
  output_list <- list()
  
  if(facet){
  
  for(i in 1:length(kmeans_list)){
    
    set.seed(123)
    k <- kmeans(kmeans_list[[i]][[1]], centers=centers)
    output <- fviz_cluster(k, data=kmeans_list[[i]][[1]], 
                 main = paste0('K-Means Cluster Analysis: ', kmeans_list[[i]][[2]]))
    
    output_list[[paste0(kmeans_list[[i]][[2]])]] <- output
    
  }
  }else{
    
    set.seed(123)
    k <- kmeans(kmeans_list[[1]], centers=centers)
    output <- fviz_cluster(k, data=kmeans_list[[1]], 
                           main = paste0('K-Means Cluster Analysis: ', kmeans_list[[2]]))
    
    output_list[[paste0(kmeans_list[[2]])]] <- output
      
    }
  
  output_list
  
}


############################# GENERATE OUTPUT ##################################

#' ******Sep Sites Bar Output******

#' Function to loop through table and apply function `prod_bar_sepsites`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepsites`
#' @param thresh boolean indicator of whether to include thresholds on plot
#' 

create_sepsite_output <- function(list_name) {
  
  output_sepsites <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- prod_bar_sepsites(data_tbl=list_name[[i]][[1]],
                               outcome=list_name[[i]][[2]])
    
    output_sepsites[[i]] <- final
  }
  
  output_sepsites
  
}

#' produces output for a given outcome (proportion of visits, median number, etc)
#' for a given data output, faceted by visit type. Side bar plots, with each bar
#' the pf_domain, or var_name. 
#' 
#' This function relies on one of the filters being BY SITE. This is a site-specific
#' output measure.
#' 
#' @param data_tbl the data tbl
#' @param outcome the outcome, as a string; must be the column name in `data_tbl`
#' @param incl_thresh boolean indicator of whether to overlay thresholds on the plot
#' 
#' @return see description; ggcharts style output
#' 

prod_bar_sepsites <- function(data_tbl,
                              outcome,
                              facet_var) {
  
  site_nm <- data_tbl %>% select(site) %>% distinct() %>% pull()
  
  color <- as.data.frame(site_colors) %>% rownames_to_column('site') %>%
    filter(site == site_nm) %>% select(site_colors) %>% pull()

    bar_chart(data_tbl, x=var_name,y=!! sym(outcome), bar_color=color) +
      ggtitle(paste0(site_nm))
}


#' ******Sep Visit Types Output******

#' Function to loop through table and apply function `prod_bar_sepvisittype`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepvisittype`
#' @param thresh boolean indicator of whether to include thresholds on plot
#' 


create_sepvisittypes_output <- function(list_name,
                                        thresh=FALSE) {
  
  output_sepvisittypes <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- prod_bar_sepvisittype(data_tbl=list_name[[i]][[1]],
                                   var_name_label=list_name[[i]][[2]],
                                   incl_thresh=thresh)
    
    output_sepvisittypes[[i]] <- final
  }
  
  output_sepvisittypes
  
  
}

#' produces output for median number of facts (for patients who have the fact)
#' for a given data input. Side bar plots, with each bar the site name. Requires 
#' site as a column in the data. As part of the `data_tbl` input, this function 
#' REQUIRES that there is a filter for a particular visit type. Otherwise, 
#' it will break.
#' 
#' 
#' @param data_tbl the data tbl
#' @param var_name_label the outcome, as a string; must be the column name in `data_tbl`
#' @param incl_thresh boolean indicator of whether to overlay thresholds on plot
#' 
#' @return see description; ggcharts style output
#' 


prod_bar_sepvisittype <- function(data_tbl,
                                  var_name_label,
                                  incl_thresh) {
  
  color <- domain_config %>% 
    filter(domain == var_name_label) %>% 
    select(domain_color) %>% pull()
  
  if(incl_thresh){
    bar_chart(data_tbl %>% filter(var_name==var_name_label), x=site,y=median_site_without0s,bar_color=color) +
      geom_line(aes(x=site,y=threshold_med,group=var_name))+
      scale_color_manual(values=site_colors) +
      ggtitle(paste0(var_name_label))
  }
  else{
    bar_chart(data_tbl %>% filter(var_name==var_name_label), x=site,y=median_site_without0s,bar_color=color) +
      scale_color_manual(values=site_colors) +
      ggtitle(paste0(var_name_label))
  }
  
}


#' ******Facet Var Output******

# Function to loop through table and apply function `prod_bar_facet`

create_facet_graphs_byvarname <- function(list_name) {
  
  output_varname <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- prod_bar_facet(data_tbl=list_name[[i]][[1]],
                            var_name_label=list_name[[i]][[2]],
                            facet_var_nm=list_name[[i]][[3]])
    
    output_varname[[i]] <- final
    
  }
  
  output_varname
}

#' stratifies bar graphs by a particular variable
#' 
#' *** NOTE THAT THIS DATA INPUT SHOULD ALREADY FILTER BY VISIT TYPE FROM THE INPUT;
#' IF NOT, ENSURE THAT THE DATA TBL ARG FILTERS BY VISIT TYPE *** 
#' 
#' 
#' @param data_tbl the data tbl
#' @param var_name_label the outcome, as a string; must be the column name in `data_tbl`
#' @param facet_var the variable to facet by (in our use case, `age_ce_grp`)
#' 
#' @return 
#' 


prod_bar_facet <- function(data_tbl,
                           var_name_label,
                           facet_var_nm) {
  
  color <- as.data.frame(domain_colors) %>%
    rownames_to_column('domain') %>%
    filter(domain == var_name_label) %>%
    select(domain_colors) %>% pull()
  
  bar_chart(data_tbl %>% filter(var_name==var_name_label), 
            facet=!! sym(facet_var_nm), x=site,y=median_site_without0s,bar_color=color) +
    ggtitle(paste0(var_name_label))
  
}


#' ******Pyramid Output******

#' Function to loop through table and apply function `produce_pyramid`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepsites`
#' 

create_sepsite_pyramids <- function(list_name) {
  
  output_sepsites <- list()
  
  for(i in 1:length(list_name)) {
    
    final <- produce_pyramid(data_tbl=list_name[[i]][[1]])
    
    output_sepsites[[i]] <- final
  }
  
  output_sepsites
  
}

#' @param data_input data to produce pyramid plots with 
#' 
#' *** NOTE THAT THE DATA INPUT SHOULD FILTER BY VISIT TYPE ***
#' 
#' @return Measure is the median number of measurements; 
#' the two bar graphs are the two cohorts in the sample
#' 

produce_pyramid  <- 
  function(data_tbl) {
    
    site_nm <- data_tbl %>% select(site) %>% distinct() %>% pull()
    
    pc <- 
      pyramid_chart(
        data=data_tbl,
        x=var_name,
        y=median_site_without0s,
        group=cohort,
        sort='ascending',
        title=paste0(site_nm),
        bar_colors = c('#6fa8dc','#93c47d')
      ) + ggtitle(paste0(site_nm))
    
  }


#' ******LOF Output******

#' computes graph of the lof_value
#' 
#' @param lof_list_output the output from `compute_lof`
#' @param remove_outliers a logical determining whether outliers shoudl be removed for the graph
#' 
#' @return A graph with overlapping density plots`for a particular site


compute_lof_graphs <- function(lof_site_output,
                               remove_outliers=TRUE) {
  
  
  if(remove_outliers) {final_reduce_lim <- 
    lof_site_output %>% filter(lof_val < 1.5,
                               !is.na(lof_val))} else {final_reduce_lim <- lof_site_output %>% 
                                 filter(!is.na(lof_val))}
  
  color_vector <- final_reduce_lim %>% select(var_name,hex_color) %>% distinct() %>% deframe()
  site_nm <- final_reduce_lim %>% select(site) %>% distinct() %>% pull()
  
  final_ggplot <- 
    ggplot(data=final_reduce_lim,
           aes(group=var_name,
               fill=var_name)) +
    geom_density(aes_string(x='lof_val',
                            #adjust=2.0,
                            alpha=0))+
    scale_fill_manual(values=color_vector) +
    labs(x='LOF Value') +
    ggtitle(paste0(site_nm))
  
  
}


#' provides table summary of LOF measures
#' 
#' @param lof_list_output the output from `compute_lof`
#' 
#' 

provide_table_lof <- function(lof_reduce_output) {
  
  
  tbls <- lof_reduce_output %>%
    # reduce(.x=collapsed_tbls,
    #        .f=dplyr::union) %>% 
    select(
      site,
      var_name,
      tenth_percentile,
      eightieth_percentile,
      ninetieth_percentile,
      ninetyfifth_percentile,
      ninetyninth_percentile
    ) %>% distinct()
  
  tbls
  
}


#' iterate through all sites `compute_lof_graphs`
#' for all sites
#' 
#' @param input_tbls the input generated from `compute_lof`
#' @param var_list_args the list of arguments that include `var_name` and associated hex color
#' @param 
#' 

#' Function to loop through table and apply function `prod_bar_sepsites`
#' 
#' @param list_name object name of the list produced from `create_list_input_sepsites`
#' 

create_sepsite_output_lofgraph <- function(lof_reduce_output) {
  
  lof_split_output <- split(lof_reduce_output, f = lof_reduce_output$site)
  
  output_sepsites <- list()
  
  for(i in 1:length(lof_split_output)) {
    
    final <- compute_lof_graphs(lof_site_output = lof_split_output[[i]])
    
    output_sepsites[[i]] <- final
  }
  
  output_sepsites
  
}


#' ******Multi-Site Output******

create_multisite_output <- function(dat){
  
  graph <- ggplot(dat, aes(x=var_name,y=median_site_without0s, colour=site))+
    geom_point(size=3)+
    geom_point(aes(x=var_name, y=median_all_without0s), shape=8, size=3, color="black")+
    facet_wrap(~visit_type, scales="free_x", ncol=2)+
    theme_bw()+
    coord_flip()
}


#' ***OVER TIME OUTPUT**
compute_plot_fot_exp <- function(fot_tbl,
                                 color_config,
                                 x_axis='start_date',
                                 y_axis='median_fact_ct',
                                 visit_type_nm='inpatient',
                                 site_nm,
                                 date_breaks_str) {
  
  colors_def <- 
    fot_tbl %>% select(domain) %>% 
    distinct() %>% left_join(color_config) %>% deframe()
  
  t <- ggplot(fot_tbl %>% filter(site==site_nm, visit_type==visit_type_nm),
              aes(x=!! sym(x_axis), y=!! sym(y_axis), group=domain, fill=domain)) +
    geom_point(aes(color=domain)) +
    geom_smooth(method='loess',formula=y~x, size=0.5) +
    scale_fill_manual(values=colors_def) +
    scale_color_manual(values=colors_def) + 
    theme_classic() +
    scale_x_date(date_breaks=date_breaks_str) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    ggtitle(paste0(site_nm, ', ', visit_type_nm, ': patient facts per domain')) +
    labs(x='Time Period', y='Median Facts Per Patient')
  
  
}


fot_check <- function(target_col,
                      tblx=results_tbl('fot_output'),
                      # check_col='check_name',
                      # check_desc='check_desc',
                      site_col='site',
                      time_col='month_end',
                      facet_var) {
  if(is.null(facet_var)){
    cols_to_keep <- c(eval(site_col),eval(time_col),'check')
    groupedlist1 <- c(time_col)
    groupedlist2 <- c(site_col)
  }else{
    cols_to_keep <- c(eval(site_col),eval(time_col),eval(facet_var),'check')
    groupedlist1 <- c(time_col, facet_var)
    groupedlist2 <- c(site_col, facet_var)
  }
  
  rv <- FALSE
  rv_agg <- FALSE
  #base tbl to make a network wide version of the check
  agg_check <- tblx %>% group_by(!!!syms(groupedlist1)) %>%
    summarise(!!sym(target_col) := sum(!!sym(target_col))) %>%
    ungroup() %>%
    mutate({{site_col}}:='all')  # I need a cheat sheet of when {{x}}/eval(x)/!!sym(x) will actually work
  
  #for (target_check in tblx %>% select(!!sym(check_col)) %>% distinct() %>% pull()) {
  for (target_site in tblx %>% select(!!sym(site_col)) %>% distinct() %>% pull()) {
    foo <- fot_check_calc(tblx %>%
                            filter(site==target_site),
                          site_col='site',
                          time_col,
                          target_col) %>% collect()
    if(!is.logical(rv)){
      rv <- union(rv, foo)
    } else {
      rv <- foo
    }
  }
  
  bar <- fot_check_calc(agg_check,
                        site_col,time_col,target_col) %>%
    select(cols_to_keep) %>% collect()
  if(!is.logical(rv_agg)){
    rv_agg <- union(rv_agg, bar)
  } else {
    rv_agg <- bar
  }
  
  rv_summary <- rv %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect()
  
  rv_summary_allsites <- rv_agg %>%
    filter(site=='all') %>% group_by(!!!syms(groupedlist2)) %>%
    summarise(std_dev = sd(check,na.rm=TRUE),
              pct_25 = quantile(check,.25),
              pct_75 = quantile(check,.75),
              med = median(check),
              m = mean(check)) %>% ungroup() %>% collect() %>%
    mutate(site='all')
  
  
  return(list(fot_heuristic= dplyr::union(rv %>% select(cols_to_keep),
                                          rv_agg),#%>% output_tbl('fot_heuristic'),
              fot_heuristic_summary=dplyr::union(rv_summary,
                                                 rv_summary_allsites))) #%>% output_tbl('fot_heuristic_summary'),
  #network_check_tbl = rv_agg %>% output_tbl('fot_heuristic_network_wide')))
}


fot_check_calc <- function(tblx, site_col,time_col, target_col) {
  tblx %>%
    #group_by(!! sym(site_col), !!sym(time_col)) %>% 
    arrange(!! sym(site_col), !! sym(time_col)) %>% 
    #window_order(!!sym(site_col),!!sym(time_col)) %>%
    mutate(
      lag_1 = lag(!!sym(target_col)),
      lag_1_plus = lead(!!sym(target_col),1),
      # lag_12 = lag(!!sym(target_col),12),
      check_denom_stupid = (lag(!!sym(target_col))*.25 +
                              lead(!!sym(target_col),1)*.25)) %>%
    # check_denom_stupid()) %>% 
    filter(check_denom_stupid!=0) %>%
    mutate(check = !!sym(target_col)/check_denom_stupid-1)
}


#' fot table computing distance from "all" check
#'
#' @param fot_check_output first element of list output from `fot_check`
#'
#' @return tbl with the following columns:
#' domain | check_name | month_end | centroid | site | check | distance
#'
#' The `distance` column measures, for each site/domain/check/month combination,
#' the distance between the site's normalized `check` output compared to
#' all sites combined.
#'

check_fot_all_dist <- function(fot_check_output) {
  
  just_all <-
    fot_check_output %>%
    filter(site=='all') %>%
    rename(centroid=check) %>%
    select(-c(site))
  
  combined <-
    just_all %>%
    inner_join(
      fot_check_output
    ) %>% mutate(
      distance=round(check,3)-round(centroid,3)
    )
}

#' Do all FOT checks; 
#' REQUIRES a column in `tblx` to be called `grp`
#' 
#' @param target_col
#' @param tblx
#' @param  site_col defaults to `site`
#' @param time_col defaults to  `month_end`
#' 

check_fot_multisite <- function(tblx,
                                target_col,
                                site_col,
                                time_col, 
                                domain_list,
                                facet_var = NULL) {
  
  final_all <- list()
  
  for(i in 1:length(domain_list)) {
    
    tblx_input <- tblx %>% filter(domain == domain_list[[i]])
    
    fot_output <- fot_check(tblx=tblx_input,
                            target_col=target_col,
                            site_col=site_col,
                            time_col=time_col,
                            facet_var=facet_var)
    
    fot_distance <- check_fot_all_dist(fot_output$fot_heuristic) %>% 
      mutate(grp_check=domain_list[[i]])
    
    final_all[[i]] <- fot_distance
    
  }
  
  letsreduce <- reduce(.x=final_all,
                       .f=dplyr::union)
  
}


#' loops through each medical complexity group
#' and produces interactive graph 
#' using `girafe` package
#' 
#' 
#' @param multisite_tbl a tbl with all sites and a `grp_check` column,
#' as well as a `month_end`, `distance`, `site` columns; output from 
#' the `check_for_multisite` function
#' 
#' @param date_breaks_str the window length for each unit of time
#' on the x-axis
#' 

create_multisite_exp <- function(multisite_tbl,
                                 date_breaks_str,
                                 facet_var = NULL,
                                 site_colors_v=site_colors) {
  
  grp_list <- 
    multisite_tbl %>% 
    select(grp_check) %>% distinct() %>% pull() %>% as.list()
  
  grp_output <- list()
  
  for(i in grp_list) {
    
    if(is.null(facet_var)){
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < '2022-12-01',start_date > '2010-03-01'),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }else{
      multisite_plot_exp <- 
        ggplot(multisite_tbl %>% 
                 filter(grp_check==i,start_date < '2022-12-01',start_date > '2010-03-01'),
               aes(x=start_date,y=distance,group=site,color=site), size=1) +
        geom_line_interactive(aes(tooltip=site, data_id=site)) +
        facet_wrap(facets = eval(facet_var))+
        scale_color_manual(values=site_colors_v)+
        scale_x_date(date_breaks=date_breaks_str) +
        theme_bw() +
        ggtitle(paste0('Multisite Exploratory: ',i)) +
        theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }
    
    multi_girafe <- 
      girafe(ggobj = multisite_plot_exp,
             width_svg = 8,
             height_svg = 4) %>% 
      girafe_options(opts_tooltip(use_fill=TRUE, css='color:black;', offx=20),
                     opts_hover(css='fill:blue;stroke-width:2;'),
                     opts_hover_inv(css='opacity:0.3'))
    
    
    grp_output[[i]] <- multi_girafe
    #ggplotly(multisite_plot_exp)
  }
  
  grp_output
}

#' output of `check_for_multisite` to look for points where
#' a site is +/- 2 MAD from the median/centoid
#' 
#' 
#' 

produce_multisite_mad <- function(multisite_tbl,
                                  facet_var = NULL,
                                  mad_dev) {
  if(is.null(facet_var)){
    grp1 <- c('start_date', 'grp_check', 'centroid')
    grp2 <- c('site', 'grp_check')
  }else{
    grp1 <- c('start_date', 'grp_check', 'centroid', facet_var)
    grp2 <- c('site', 'grp_check', facet_var)
  }
  
  mad_computation <- 
    multisite_tbl %>% 
    group_by(!!!syms(grp1)) %>% 
    summarise(mad_pt=mad(check, center=centroid)) %>% 
    ungroup() %>% 
    mutate(lower_mad = mad_pt - (abs(mad_pt*mad_dev)),
           upper_mad = mad_pt + (abs(mad_pt*mad_dev)))
  
  full_tbl_outliers <- 
    multisite_tbl %>% ungroup() %>% 
    inner_join(mad_computation) %>% 
    mutate(
      outlier=case_when((distance < lower_mad) | (distance > upper_mad) ~ 1,
                        TRUE ~ 0)
    ) %>% filter(! site=='all')
  
  sites_grp_outliers <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    filter(outlier==1) %>% 
    summarise(grp_outlier_num=n()) %>%  ungroup() 
  
  sites_grp_ct_total <- 
    full_tbl_outliers %>% 
    group_by(!!!syms(grp2)) %>% 
    summarise(grp_total_num=n()) %>% ungroup()
  
  sites_grp_total <- 
    sites_grp_ct_total %>% 
    left_join(sites_grp_outliers) %>% 
    mutate(grp_outlier_prop = round(grp_outlier_num/grp_total_num,2))
  
  sites_total <- 
    sites_grp_total %>% ungroup() %>% 
    group_by(site) %>% 
    mutate(site_total_num=sum(grp_total_num),
           site_total_outlier=sum(grp_outlier_num)) %>% 
    mutate(site_outlier_prop=round(site_total_outlier/site_total_num,2)) %>% 
    rename(grp=grp_check)
  
}

#' produce graphs from output
#' 
#' @param multisite_anomaly_tbl
#' 

produce_multisite_anom <- function(multisite_anomaly_tbl,
                                   color_config,
                                   outcome_var) {
  
  
  
  colors_def <- 
    multisite_anomaly_tbl %>% ungroup() %>% select(grp) %>% distinct() %>% deframe()
    #left_join(color_config) %>% deframe()
  
  t <- 
    ggplot(multisite_anomaly_tbl,
           aes(x=site, y=grp, fill=!!sym(outcome_var))) +
    geom_tile() +
    #scale_fill_manual(values=colors_def) +
    theme_classic() +
    coord_flip() +
    labs(fill = 'Proportion',
         y = 'Domain',
         title = 'MAD Across Sites over Time: Multi-Site Anomaly Detection')
  
  
}
